<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Square Dodger ‚Äî EXP48PRO Edition</title>
  <style>
    :root {
      --bg: #0f1226;
      --fg: #e7e9ff;
      --accent: #7aa2ff; /* UI accent */
      --accent2: #9ef0c0; /* power-up green */
      --danger: #ff6b6b; /* outage */
    }
    html, body { margin: 0; background: radial-gradient(1200px 800px at 50% 20%, #1a1f49 0%, var(--bg) 45%, #0b0e1d 100%); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; -webkit-user-select: none; user-select: none; overflow: visible; }
    .wrap { display: flex; justify-content: center; align-items: flex-start; padding: 12px 8px; }
    .stage { position: relative; display: block; width: 100%; max-width: 900px; margin: 0 auto; }
    
    canvas { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.15)); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.08); outline: none; touch-action: none; -webkit-user-select: none; user-select: none; max-width: 100%; height: auto; }
    .hud { position: static; display: flex; justify-content: center; gap: 12px; font-weight: 600; margin-bottom: 8px; width: 100%; }
    .pill { padding: 6px 12px; border-radius: 999px; background: rgba(255,255,255,0.06); }
    .controls { position: static; margin-top: 8px; opacity: 0.9; font-size: clamp(12px, 2.5vw, 14px); text-align: center; width: 100%; }
  .touchbar { display: none; justify-content: center; gap: 12px; margin-top: 10px; }
    .touchbar button { padding: 12px 20px; border-radius: 999px; background: rgba(255,255,255,0.08); color: var(--fg); border: 1px solid rgba(255,255,255,0.15); font-size: clamp(18px, 6vw, 24px); line-height: 1; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    .touchbar button:active { transform: scale(0.97); }
    @media (max-width: 640px) { .touchbar { display: flex; } }
  .name-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .name-modal { background: #1b1f3a; border: 1px solid rgba(255,255,255,0.15); border-radius: 14px; padding: 16px; width: min(92vw, 360px); box-shadow: 0 10px 30px rgba(0,0,0,0.45); }
    .name-modal h3 { margin: 0 0 10px; font-size: 16px; color: var(--fg); text-align: center; }
    .name-modal input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); color: var(--fg); outline: none; }
    .name-modal .actions { display: flex; gap: 8px; margin-top: 12px; }
    .name-modal button { flex: 1; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08); color: var(--fg); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div class="hud" aria-live="polite">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Best: <span id="best">0</span></div>
        <div class="pill">Charge: <span id="charge">100%</span></div>
      </div>
      <canvas id="game" width="420" height="500" tabindex="0" aria-label="EXP48PRO battery game"></canvas>
      <div class="controls pill">Move: ‚óÄ ‚ñ∂ / A D &nbsp;‚Ä¢&nbsp; Start/Restart: Space &nbsp;‚Ä¢&nbsp; Pause: P &nbsp;‚Ä¢&nbsp; <strong>Name: N</strong> &nbsp;‚Ä¢&nbsp; Collect green power-ups, avoid outages</div>
      <div class="touchbar">
        <button id="btnLeft" aria-label="Move left">‚óÄ</button>
        <button id="btnStart" aria-label="Start / Pause">‚èØ</button>
        <button id="btnRight" aria-label="Move right">‚ñ∂</button>
        <button id="btnName" aria-label="Set name">üë§</button>
      </div>
      <!-- Name modal overlay -->
      <div class="name-modal-backdrop" id="nameModal" role="dialog" aria-modal="true" aria-labelledby="nameTitle">
        <div class="name-modal">
          <h3 id="nameTitle">Enter your player name</h3>
          <input id="nameField" type="text" maxlength="20" placeholder="e.g., NightOwl" />
          <div class="actions">
            <button id="saveNameBtn">Save</button>
            <button id="cancelNameBtn">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function() {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // HiDPI
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const BASE_W = canvas.width, BASE_H = canvas.height;
    canvas.width = BASE_W * DPR;
    canvas.height = BASE_H * DPR;
    ctx.scale(DPR, DPR);

    function fitToScreen(){
      const margin = 16;
      const container = canvas.parentElement; // .stage
      const containerW = (container ? container.clientWidth : window.innerWidth) - margin*2;
      const displayW = Math.max(320, Math.min(containerW, 900));
      const scale = displayW / BASE_W;
      canvas.style.width = displayW + 'px';
      canvas.style.height = (BASE_H * scale) + 'px';
    }
    window.addEventListener('resize', fitToScreen);
    fitToScreen();

    // Utils
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => a + Math.random() * (b - a);    // --- Leaderboard & player name helpers ---
    // Local fallback (used if network fails)
    const LB_KEY = 'sq_leaderboard_v1';
    function loadLB(){ try{ const a = JSON.parse(localStorage.getItem(LB_KEY)||'[]'); return Array.isArray(a)?a:[]; }catch(_){ return []; } }
    function saveLB(a){ try{ localStorage.setItem(LB_KEY, JSON.stringify(a)); }catch(_){ /* ignore quota */ } }
    function getPlayerBestLocal(name){ const lb = loadLB(); const e = lb.find(x=>x.name===name); return e?e.score:0; }
    function upsertLBLocal(name, score){
      let lb = loadLB();
      const now = Date.now();
      const i = lb.findIndex(e=>e.name===name);
      if (i>=0) { if (score > lb[i].score) { lb[i].score = score; lb[i].date = now; } }
      else { lb.push({name, score, date: now}); }
      lb.sort((a,b)=> (b.score - a.score) || (a.date - b.date));
      if (lb.length > 20) lb.length = 20; // keep top 20
      saveLB(lb);
      const rank = lb.findIndex(e=>e.name===name) + 1;
      return {rank, lb};
    }

    // Remote API (configure with window.LEADERBOARD_API_BASE or default to /api/leaderboard)
    const API_BASE = (window.LEADERBOARD_API_BASE || '/api/leaderboard');
    const API = {
      async fetchTop(limit=20){
        const r = await fetch(`${API_BASE}?limit=${encodeURIComponent(limit)}`, { method:'GET' });
        if(!r.ok) throw new Error('leaderboard fetch failed');
        return r.json(); // { lb: [{name,score}] }
      },
      async submit(name, score){
        const r = await fetch(API_BASE, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name, score }) });
        if(!r.ok) throw new Error('leaderboard submit failed');
        return r.json(); // { rank, lb }
      }
    };

    let remoteLB = null;     // latest fetched leaderboard
    let lbLoading = false;   // loading flag

    function updateBestFromLB(){
      if(!playerName) return;
      const e = (remoteLB||[]).find(x=>x.name===playerName);
      state.best = e ? e.score : 0;
      const bestEl=document.getElementById('best'); if(bestEl) bestEl.textContent = state.best;
    }

    function refreshLeaderboard(limit=20){
      lbLoading = true;
      API.fetchTop(limit).then(res=>{
        remoteLB = res.lb || [];
        lbLoading = false;
        updateBestFromLB();
      }).catch(_=>{ lbLoading = false; /* fall back to local */ });
    }

    function submitHighScore(final){
      return API.submit(playerName||'Player', final).then(res=>{
        remoteLB = res.lb || remoteLB;
        lastRank = (res.rank==null ? null : res.rank);
        lastLBSize = (remoteLB ? remoteLB.length : lastLBSize);
        updateBestFromLB();
        draw();
        return res;
      }).catch(_=>{
        const {rank, lb} = upsertLBLocal(playerName||'Player', final);
        lastRank = rank; lastLBSize = lb.length;
        if(!remoteLB) remoteLB = lb;
        updateBestFromLB();
        draw();
        return {rank, lb};
      });
    }
    // --- /Leaderboard helpers ---

    // Game state
    const state = {
      running: false,
      paused: false,
      over: false,
      t: 0,
      score: 0,
      best: Number(localStorage.getItem('sq_best') || 0),
      // spawn control
      spawnTimer: 0,
      spawnInterval: 0.9, // obstacles (will ramp)
      powerTimer: 0,
      powerInterval: 2.0, // power-ups (will ramp)
      speed: 120,
      // entities
      obstacles: [], // outages
      powerups: [],  // green energy
      popups: [],
      stars: [],
      // battery (player resource)
      maxCharge: 300,
      charge: 300,
    };

    // Player ‚Äî EXP48PRO battery (drawn)
    const player = {
      x: BASE_W / 2,
      y: BASE_H - 68,
      w: 42,
      h: 60,
      nubW: 16,
      nubH: 8,
      vx: 0,
      speed: 360,
    };

    // Input
    const keys = new Set();
    let touchDir = 0; // -1 left, 1 right, 0 idle
    window.addEventListener('keydown', (e) => {
      if (typingInUI(e)) return; // don't intercept when typing name
      if (['ArrowLeft','ArrowRight','KeyA','KeyD','Space','KeyP','KeyN'].includes(e.code)) e.preventDefault();
      keys.add(e.code);
      if (!state.running && (e.code === 'Space' || e.code === 'Enter')) start();
      else if (state.over && e.code === 'Space') restart();
      else if (e.code === 'KeyP') togglePause();
      else if (e.code === 'KeyN') { showNameModal(); }
    }, {passive:false});
    document.addEventListener('keydown', (e)=>{
      if (typingInUI(e)) return; // let the input receive letters like a/d/q/e/p
      const code = e.code || '';
      const key = e.key || '';
      if (code === 'KeyN' || key === 'n' || key === 'N') {
        e.preventDefault();
        e.stopPropagation();
        showNameModal();
      }
    }, true);
    window.addEventListener('keyup', (e) => { if (typingInUI(e)) return; keys.delete(e.code); });
    canvas.addEventListener('click', () => { if (!state.running) start(); else if (state.over) restart(); });

    // On-screen buttons (mobile)
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnStart = document.getElementById('btnStart');
    function bindHold(el, dir){
      if(!el) return;
      el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); touchDir = dir; el.setPointerCapture(e.pointerId); }, {passive:false});
      ['pointerup','pointercancel','pointerleave'].forEach(t=> el.addEventListener(t, ()=>{ touchDir = 0; }));
    }
    bindHold(btnLeft, -1);
    bindHold(btnRight, 1);
    if (btnStart) btnStart.addEventListener('click', ()=>{ if (!state.running) start(); else if (state.over) restart(); else togglePause(); });
    const btnName = document.getElementById('btnName');

    // Name modal controls
    const nameModal = document.getElementById('nameModal');
    const nameField = document.getElementById('nameField');
    const saveNameBtn = document.getElementById('saveNameBtn');
    const cancelNameBtn = document.getElementById('cancelNameBtn');

    // Helpers to avoid stealing keys while typing in UI
    let nameOpen = false;
    function inNameModal(){ return nameOpen; }
    function typingInUI(e){ const el = e && e.target; return nameOpen || (el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable)); }

    function showNameModal(){
      if (!nameModal) return;
      state.paused = true; // pause while editing
      keys.clear(); touchDir = 0;
      const prev = (localStorage.getItem('sq_player_name')||'').trim();
      if (nameField) nameField.value = prev || playerName || '';
      nameOpen = true; nameModal.style.display = 'flex';
      setTimeout(()=>{ if (nameField) nameField.focus(); }, 0);
    }
    function hideNameModal(){ if (nameModal) { nameOpen = false; nameModal.style.display = 'none'; } }
    function commitName(){
      if (!nameField) return;
      const v = (nameField.value||'').trim().slice(0,20);
      if (!v) { nameField.focus(); return; }
      playerName = v;
      localStorage.setItem('sq_player_name', playerName);
      state.best = getPlayerBestLocal(playerName) || 0;
      const bestEl = document.getElementById('best'); if (bestEl) bestEl.textContent = state.best;
      hideNameModal();
    }
    if (btnName) btnName.addEventListener('click', ()=>{ showNameModal(); });
    if (saveNameBtn) saveNameBtn.addEventListener('click', commitName);
    if (cancelNameBtn) cancelNameBtn.addEventListener('click', hideNameModal);
    if (nameField) nameField.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') commitName();
      else if (e.key === 'Escape') hideNameModal();
    });

    // Canvas pointer controls (tap left/right half) (tap left/right half)
    let pointerActive = false;
    canvas.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      if (!state.running) { start(); return; }
      pointerActive = true;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      touchDir = (x < rect.width/2) ? -1 : 1;
      canvas.setPointerCapture(e.pointerId);
    }, {passive:false});
    canvas.addEventListener('pointermove', (e)=>{
      if(!pointerActive) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      touchDir = (x < rect.width/2) ? -1 : 1;
    });
    ['pointerup','pointercancel','pointerleave'].forEach(t=> canvas.addEventListener(t, ()=>{ pointerActive=false; touchDir = 0; }));

    // Auto-pause when tab hidden
    document.addEventListener('visibilitychange', () => { if (document.hidden) state.paused = true; });

    // HUD init
    state.best = 0; // will update after remote leaderboard loads
    document.getElementById('best').textContent = state.best;
    updateChargeHUD();
    refreshLeaderboard();

    // Starfield
    for (let i = 0; i < 80; i++) state.stars.push({ x: Math.random()*BASE_W, y: Math.random()*BASE_H, r: Math.random()*1.8 + 0.4, s: Math.random()*0.4 + 0.1 });

    function start() {
      if (state.running) return;
      if (!ensureName()) return;
      state.running = true; state.over = false; state.paused = false;
      state.t = 0; state.score = 0; state.spawnTimer = 0; state.powerTimer = 0;
      state.spawnInterval = 0.85; state.powerInterval = 1.9; state.speed = 120;
      state.obstacles.length = 0; state.powerups.length = 0; state.charge = state.maxCharge;
      player.x = BASE_W / 2; player.vx = 0;
      lastTime = performance.now();
      requestAnimationFrame(loop);
      updateChargeHUD();
    }

    function restart() { state.over = false; start(); }
    function togglePause() { if (!state.running || state.over) return; state.paused = !state.paused; }

    // Spawns
    function spawnObstacle() {
      const margin = 22; const w = rand(22, 46); const h = rand(22, 46);
      const x = rand(margin, BASE_W - margin - w);
      const speedJitter = rand(-10, 50);
      state.obstacles.push({ x, y: -60, w, h, vy: state.speed + speedJitter, kind: 'outage' });
    }
    function spawnPowerup() {
      // Size tiers with rarity; bigger = more charge value
      const roll = Math.random();
      let tier, r;
      if (roll < 0.65) { tier = 'small';  r = rand(6, 12); }
      else if (roll < 0.88) { tier = 'medium'; r = rand(12, 18); }
      else if (roll < 0.985) { tier = 'large';  r = rand(18, 26); }
      else { tier = 'mega';   r = rand(26, 36); } // rare mega orb

      const x = rand(16 + r, BASE_W - 16 - r);
      let value;
      if (tier === 'small') value = Math.round(4  + (r - 6 ) * 1.2);
      else if (tier === 'medium') value = Math.round(12 + (r - 12) * 1.4);
      else if (tier === 'large') value = Math.round(20 + (r - 18) * 1.6);
      else value = Math.round(40 + (r - 26) * 2.0); // mega: big bump

      state.powerups.push({ x, y: -30, r, vy: state.speed * 0.8, kind: 'charge', value, tier });
    }

    // Collision helpers
    function aabbRect(a, b) {
      return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
    }
    function circleRect(cx, cy, r, rx, ry, rw, rh) {
      // clamp circle center to rect
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx, dy = cy - ny;
      return dx*dx + dy*dy <= r*r;
    }

    // Loop
    let lastTime = performance.now();
    function loop(now) {
      const dt = Math.min(0.04, (now - lastTime) / 1000); lastTime = now;
      if (!state.paused && state.running && !state.over) update(dt);
      draw();
      if (state.running) requestAnimationFrame(loop);
    }

    function update(dt) {
      state.t += dt;

      // Faster difficulty ramp
      const ramp = 1 + state.t * 0.05; // grows over time
      state.speed = 120 * ramp;
      state.spawnInterval = clamp(0.85 / ramp, 0.16, 0.85);
      state.powerInterval = clamp(1.9 / ramp, 0.7, 2.5);

      // Movement
      const left = keys.has('ArrowLeft') || keys.has('KeyA');
      const right = keys.has('ArrowRight') || keys.has('KeyD');
      let vx = 0;
      if (left) vx -= 1;
      if (right) vx += 1;
      vx += touchDir;
      player.vx = Math.max(-1, Math.min(1, vx));
      player.x += player.vx * player.speed * dt;
      player.x = clamp(player.x, 8, BASE_W - player.w - 8);

      // Stars
      for (const s of state.stars) { s.y += (40 + s.s * 60) * dt; if (s.y > BASE_H + 2) { s.y = -2; s.x = Math.random()*BASE_W; } }

      // Spawning
      state.spawnTimer += dt; state.powerTimer += dt;
      if (state.spawnTimer >= state.spawnInterval) { state.spawnTimer = 0; spawnObstacle(); }
      if (state.powerTimer >= state.powerInterval) { state.powerTimer = 0; spawnPowerup(); }

      // Update entities
      for (const o of state.obstacles) o.y += o.vy * dt;
      for (const p of state.powerups) p.y += p.vy * dt;
      state.obstacles = state.obstacles.filter(o => o.y < BASE_H + 80);
      state.powerups = state.powerups.filter(p => p.y < BASE_H + 40);

      // Floating text popups
      for (const f of state.popups) { f.y += f.vy * dt; f.ttl -= dt; }
      state.popups = state.popups.filter(f => f.ttl > 0);

      // Score
      state.score += dt * 10;
      document.getElementById('score').textContent = Math.floor(state.score);

      // Collisions ‚Äî outages drain, power-ups charge
      // Battery rect (body + nub combined)
      const batteryRect = { x: player.x, y: player.y, w: player.w, h: player.h + player.nubH };

      // Power-ups
      for (let i = state.powerups.length - 1; i >= 0; i--) {
        const p = state.powerups[i];
        if (circleRect(p.x, p.y, p.r, batteryRect.x, batteryRect.y, batteryRect.w, batteryRect.h)) {
          state.powerups.splice(i, 1);
          modifyCharge(p.value);
          state.score += Math.max(5, Math.round(p.value));
          state.popups.push({ x: p.x, y: p.y, text: '+' + p.value, ttl: 0.9, life: 0.9, vy: -50 });
        }
      }

      // Obstacles
      for (let i = state.obstacles.length - 1; i >= 0; i--) {
        const o = state.obstacles[i];
        if (aabbRect(batteryRect, o)) {
          state.obstacles.splice(i, 1);
          // Drain more as game speeds up, but cap
          const drain = clamp(10 + state.t * 0.8, 10, 24); // gentler drain so it takes more hits
          modifyCharge(-drain);
          // brief knock effect
          player.x += (Math.random() < 0.5 ? -1 : 1) * 10;
        }
      }

      if (state.charge <= 0) gameOver();
    }

    function modifyCharge(delta) {
      state.charge = clamp(Math.round(state.charge + delta), 0, state.maxCharge);
      updateChargeHUD();
    }

    function updateChargeHUD() {
      const el = document.getElementById('charge');
      if (el) {
        const pct = Math.round((state.charge / state.maxCharge) * 100);
        el.textContent = pct + '%';
      }
    }

    function gameOver() {
      state.over = true; state.running = false;
      const final = Math.floor(state.score);
      // Post score to backend, fall back to local if network fails
      submitHighScore(final);
    } = upsertLB(playerName || 'Player', final);
      lastRank = rank; lastLBSize = lb.length;
      // Update HUD best for this player
      state.best = getPlayerBestLocal(playerName || 'Player') || 0;
      document.getElementById('best').textContent = state.best;
      draw();
    }

    // Drawing
    function draw() {
      ctx.clearRect(0, 0, BASE_W, BASE_H);

      // starfield
      for (const s of state.stars) { ctx.globalAlpha = 0.5 + Math.sin((s.x + s.y)*0.05) * 0.25; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fillStyle = '#e7e9ff'; ctx.fill(); }
      ctx.globalAlpha = 1;

      // ground glow
      const grd = ctx.createLinearGradient(0, BASE_H - 120, 0, BASE_H);
      grd.addColorStop(0, 'rgba(122,162,255,0.0)');
      grd.addColorStop(1, 'rgba(122,162,255,0.15)');
      ctx.fillStyle = grd; ctx.fillRect(0, BASE_H - 120, BASE_W, 120);

      // Player as drawn EXP48PRO battery
      drawBattery(player.x, player.y, player.w, player.h, player.nubW, player.nubH, state.charge / state.maxCharge);

      // Obstacles (power outages)
      for (const o of state.obstacles) {
        drawOutage(o.x, o.y, o.w, o.h);
      }

      // Power-ups (green cells with plus)
      for (const p of state.powerups) { drawPowerUp(p); }

      // floating pickup labels
      for (const f of state.popups) {
        const alpha = clamp(f.ttl / f.life, 0, 1);
        ctx.save();
        ctx.globalAlpha = 0.3 + 0.7 * alpha;
        ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 3;
        ctx.strokeText(f.text, f.x, f.y - 10);
        ctx.fillText(f.text, f.x, f.y - 10);
        ctx.restore();
      }

      // UI overlays
      if (!state.running && !state.over) { titleCard('EXP48PRO RUN', 'Collect green power ‚Ä¢ avoid outages ‚Ä¢ Space to Start'); drawLeaderboard(); }
      if (state.paused) { banner('Paused ‚Äî press P to resume'); }
      if (state.over) {
        titleCard('POWER DEPLETED', 'Space to Restart');
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.font = '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.fillText(`Final: ${Math.floor(state.score)}  ‚Ä¢  Best: ${state.best}` , BASE_W/2, BASE_H/2 + 52);
        if (lastRank != null) {
          ctx.fillText(`Rank: #${lastRank} of ${lastLBSize}` , BASE_W/2, BASE_H/2 + 72);
        }
        drawLeaderboard();
      }

      // Charge bar at top
      drawChargeBar(24, 20, BASE_W - 48, 10, state.charge / state.maxCharge);
    }

    function drawRoundedRect(x, y, w, h, r, color) { ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); ctx.fillStyle = color; ctx.fill(); }

    function drawBattery(x, y, w, h, nubW, nubH, pct) {
      // body
      drawRoundedRect(x, y, w, h, 8, '#1f254a');
      // outline
      ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1; ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
      // nub
      const nx = x + (w - nubW)/2; const ny = y - nubH; drawRoundedRect(nx, ny, nubW, nubH, 3, '#1f254a');
      ctx.strokeRect(nx+0.5, ny+0.5, nubW-1, nubH-1);
      // charge fill
      const pad = 6; const ih = h - pad*2; const iw = w - pad*2;
      const fillH = Math.max(4, ih * pct);
      ctx.fillStyle = pct > 0.5 ? '#9ef0c0' : pct > 0.2 ? '#f2d264' : '#ff8181';
      ctx.fillRect(x+pad, y+pad + (ih - fillH), iw, fillH);
      // label
      ctx.fillStyle = 'rgba(231,233,255,0.95)';
      ctx.font = 'bold 10px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.textAlign = 'center';
      ctx.fillText('EXP48PRO', x + w/2, y + h/2 + 4);
    }

    function drawOutage(x, y, w, h) {
      drawRoundedRect(x, y, w, h, 6, 'rgba(255,107,107,0.9)');
      // lightning glyph
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate(0.05);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.moveTo(-4, -8); ctx.lineTo(2, -8); ctx.lineTo(-1, 0); ctx.lineTo(5, 0); ctx.lineTo(-2, 12); ctx.lineTo(0, 2); ctx.lineTo(-6, 2); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawPowerUp(p) {
      const cx = p.x, cy = p.y, r = p.r;
      if (p.tier === 'mega') {
        // golden multi-glow
        ctx.beginPath(); ctx.arc(cx, cy, r + 8, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,215,122,0.35)'; ctx.fill();
        ctx.beginPath(); ctx.arc(cx, cy, r + 3, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,215,122,0.25)'; ctx.fill();
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fillStyle = '#ffd76a'; ctx.fill();
        // subtle rotating starbursts
        ctx.save(); ctx.translate(cx, cy); ctx.rotate((state.t*2) % (Math.PI*2));
        for (let i=0;i<4;i++){ ctx.rotate(Math.PI/4); ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fillRect(-1, -r*0.9, 2, r*0.6); }
        ctx.restore();
        // plus sign
        ctx.fillStyle = '#0f1226';
        ctx.fillRect(cx - 1.2, cy - r*0.7, 2.4, r*1.4);
        ctx.fillRect(cx - r*0.7, cy - 1.2, r*1.4, 2.4);
      } else {
        // regular green
        ctx.beginPath(); ctx.arc(cx, cy, r+3, 0, Math.PI*2); ctx.fillStyle = 'rgba(158,240,192,0.25)'; ctx.fill();
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fillStyle = '#9ef0c0'; ctx.fill();
        ctx.fillStyle = '#0f1226';
        ctx.fillRect(cx - 1, cy - r*0.6, 2, r*1.2);
        ctx.fillRect(cx - r*0.6, cy - 1, r*1.2, 2);
      }
      // value label above the orb
      const fs = Math.round(Math.max(10, Math.min(16, r*0.7 + 6)));
      ctx.font = 'bold ' + fs + 'px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.textAlign = 'center';
      ctx.strokeStyle = 'rgba(0,0,0,0.45)';
      ctx.lineWidth = 3;
      ctx.strokeText('+' + p.value, cx, cy - r - 6);
      ctx.fillStyle = '#0f1226';
      ctx.fillText('+' + p.value, cx, cy - r - 6);
    }

    function drawChargeBar(x, y, w, h, pct) {
      ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(x, y, w, h);
      ctx.fillStyle = '#9ef0c0'; ctx.fillRect(x, y, w * pct, h);
      ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
    }

    // Draw leaderboard panel inside canvas
    function drawLeaderboard(){
      const lb = (remoteLB && remoteLB.length ? remoteLB : loadLB());
      const pad = 14, rowH = 18, maxRows = 8;
      const w = BASE_W - 80, x = 40;
      const h = pad*2 + rowH * (Math.min(maxRows, lb.length || 0) + 2);
      const y = Math.min(BASE_H - (h + 24), BASE_H/2 + 20);
      // panel
      ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
      ctx.textAlign = 'left';
      ctx.font = 'bold 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillStyle = 'rgba(231,233,255,0.95)';
      if (lbLoading && (!remoteLB || !remoteLB.length)) {
        ctx.fillText('Leaderboard ‚Äî loading‚Ä¶', x+pad, y+pad+2);
        return;
      }
      ctx.fillText(`Leaderboard (Top ${Math.min(20, (lb && lb.length) || 0)})`, x+pad, y+pad+2);
      ctx.font = '14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      const show = (lb||[]).slice(0, maxRows);
      for (let i=0; i<show.length; i++){
        const e = show[i];
        const lineY = y + pad + 26 + i*rowH;
        const isMe = (playerName && e.name === playerName);
        ctx.fillStyle = isMe ? '#9ef0c0' : 'rgba(231,233,255,0.9)';
        ctx.fillText(`#${i+1}  ${e.name}`, x+pad, lineY);
        ctx.textAlign = 'right';
        ctx.fillText(`${e.score}`, x + w - pad, lineY);
        ctx.textAlign = 'left';
      }
      if (playerName && lb && lb.length) {
        const r = lb.findIndex(e=>e.name===playerName);
        if (r >= 0 && r >= maxRows) {
          ctx.fillStyle = '#9ef0c0';
          ctx.fillText(`‚Ä¶  #${r+1}  ${playerName} ‚Äî ${lb[r].score}`, x+pad, y + pad + 26 + maxRows*rowH);
        }
      }
      ctx.fillStyle = 'rgba(231,233,255,0.75)'; ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillText('Press N to set your name' + (playerName ? ' (current: ' + playerName + ')' : ''), x+pad, y + h - pad);
    })`, x+pad, y+pad+2);
      ctx.font = '14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      const show = lb.slice(0, maxRows);
      for (let i=0; i<show.length; i++){
        const e = show[i];
        const lineY = y + pad + 26 + i*rowH;
        const isMe = (playerName && e.name === playerName);
        ctx.fillStyle = isMe ? '#9ef0c0' : 'rgba(231,233,255,0.9)';
        ctx.fillText(`#${i+1}  ${e.name}`, x+pad, lineY);
        ctx.textAlign = 'right';
        ctx.fillText(`${e.score}`, x + w - pad, lineY);
        ctx.textAlign = 'left';
      }
      if (playerName) {
        const r = lb.findIndex(e=>e.name===playerName);
        if (r >= 0 && r >= maxRows) {
          ctx.fillStyle = '#9ef0c0';
          ctx.fillText(`‚Ä¶  #${r+1}  ${playerName} ‚Äî ${lb[r].score}`, x+pad, y + pad + 26 + maxRows*rowH);
        }
      }
      ctx.fillStyle = 'rgba(231,233,255,0.75)'; ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillText('Press N to set your name' + (playerName ? ' (current: ' + playerName + ')' : ''), x+pad, y + h - pad);
    }

    function titleCard(title, subtitle) {
      ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(40, BASE_H/2 - 90, BASE_W - 80, 160);
      ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.strokeRect(40.5, BASE_H/2 - 89.5, BASE_W - 81, 159);
      ctx.textAlign = 'center';
      ctx.font = 'bold 28px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.shadowColor = 'rgba(122,162,255,0.6)'; ctx.shadowBlur = 12; ctx.fillStyle = '#e7e9ff'; ctx.fillText(title, BASE_W/2, BASE_H/2 - 12); ctx.shadowBlur = 0;
      ctx.font = '14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto'; ctx.fillStyle = 'rgba(231,233,255,0.9)'; ctx.fillText(subtitle, BASE_W/2, BASE_H/2 + 18);
    }

    function banner(text) { ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(40, 24, BASE_W - 80, 40); ctx.textAlign = 'center'; ctx.font = 'bold 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto'; ctx.fillStyle = '#e7e9ff'; ctx.fillText(text, BASE_W/2, 50); }

    // Focus and initial draw
    setTimeout(() => canvas.focus(), 0); draw();
  })();
  </script>
</body>
</html>
